---
title: 'Block Autoplay: Comparison of Battery Drain'
author: 'Corey Dow-Hygelund, Mozilla Data Science'
output:
  pdf_document: default
  html_document:
    df_print: paged
---

A suite of experiments were performed, as [previously described](https://drive.google.com/open?id=1O6KCGYeM7vM8igOzkpqHxRRMnk5AXpxQa0YrbIJTQnM), with both the block autoplay on and off to determine its influence on power usage/battery consumption. The current experimentation process utilizes _Intel Power Gadget_ to measure battery consumption using `Processor Energy` as a proxy. 


```{r, message=FALSE, echo=FALSE}
library(tibble)
library(knitr)
source('../data_munge.R')
```

```{r, echo=FALSE}
exp_types = list()
for (exp_dir in dir('data/', full.names = TRUE)){
  pref <- str_split(exp_dir, '_', n=2)[[1]][2]
  exps <- get_exp_data(exp_dir)
  perf_merged <- merge_perf_data(exps)
  exp_types[[pref]] = perf_merged
}

```

```{r, echo=FALSE}
calc_battery_diff <- function(prefs, exps){
  perf_merged <- exps[[prefs]]
  b_diff <- list()
  for (exp in names(perf_merged)){
    df <- perf_merged[[exp]] %>%
      group_by(run_id) %>%
      summarize_at(c("level", "percent", "battery_drain",
                     "Cumulative.GT.Energy_0.Joules.",
                     "Cumulative.IA.Energy_0.mWh."), 
                   function (x) diff(range(x))[1]) %>%
      mutate(run_id = as.character(run_id), exp=exp, prefs=prefs) %>%
      rename(gpu_pwr_drain = Cumulative.GT.Energy_0.Joules.,
             cpu_pwr_drain = Cumulative.IA.Energy_0.mWh.,
             pwr_drain = battery_drain)
    b_diff[[exp]] <- df
  }
  b_df <- bind_rows(b_diff)
  return(b_df)
}

battery_diff <- lapply(names(exp_types), calc_battery_diff, exps=exp_types) %>%
  bind_rows()
```


# Full experiment

```{r, echo=FALSE}
ggplot(battery_diff[battery_diff$run_id < 5, ], aes(run_id, pwr_drain, 
                                                    fill=prefs)) + 
  geom_violin(position = position_dodge(width=0.8)) + 
  geom_boxplot(width=0.1, position=position_dodge(width=0.8)) +
  xlab('Run ID') + 
  ylab('IPG Total Power Drain') +
  theme_bw()
```

The missing high outlier for run #4 is due to an incomplete final Lingcars run (battery ran out). There is the expected drop in the block autoplay power consumption. Another interesting effect, is the significantly higher run #1 power drain values for block autoplay off, which drops for run #2, and even more to #3. This is also true, to a lesser degree, for block autoplay on for run #1.

**Question**: Is this an effect due to the drain rate being dependent upon charge? Or is it solely due to caching? 

   - **TODO**: Reform experiment with mutiple charges due to determine the influence of caching versus charge capacity.


GPU should be changing significantly between the pref-flip:

```{r, echo=FALSE}
ggplot(battery_diff[battery_diff$run_id < 5, ], aes(run_id, gpu_pwr_drain, 
                                                    fill=prefs)) + 
  geom_violin(position = position_dodge(width=0.8)) + 
  geom_boxplot(width=0.1, position=position_dodge(width=0.8)) + 
  xlab('IPG GPU Power Drain') + 
  ylab('Run ID')+
  theme_bw()

```

The spread and quantiles are greater for block autoplay off. Zooming in

```{r, echo=FALSE, warning=FALSE}
ggplot(battery_diff[battery_diff$run_id < 5, ], aes(run_id, gpu_pwr_drain, 
                                                    fill=prefs)) + 
  geom_violin(position = position_dodge(width=0.8)) + 
  geom_boxplot(width=0.1, position=position_dodge(width=0.8)) + 
  ylab('IPG GPU Power Drain') + 
  xlab('Run ID') + 
  coord_cartesian(ylim = c(0, 20))+
  theme_bw()

```

The higher values in run #1 and #2 is not observed for GPU usage. In fact for block autoplay on #1 is lower.


Observing the CPU/cores power usage:

```{r, echo=FALSE}
ggplot(battery_diff[battery_diff$run_id < 5, ], aes(run_id, cpu_pwr_drain, 
                                                    fill=prefs)) + 
  geom_violin(position = position_dodge(width=0.8)) + 
  geom_boxplot(width=0.1, position=position_dodge(width=0.8)) + 
  ylab('IPG CPU Power Drain') + 
  xlab('Run ID')+
  theme_bw()
```

The increased usage in run 1-2 is due to CPU usage. It is interesting to note the block autoplay influences _both_ the CPU and GPU power drain. 

# Before/After/During URL Navigation
It has been observed that the battery level might have an influence on the rate of battery drain. Moreover, there is the possibility of run order also influencing this rate. One item to investigate is the rate of power usage before, during, and after navigation to the URL. An informative plot:

```{r, echo=FALSE}
library(tidyr)
df <- exp_types[["blockautoplay_off_tpstrict_off"]][["exp_lingscars"]] %>%
  filter(run_id == 1) %>%
  rename(`IPG Power Usage` = battery_drain, `Performance Counts` =  counts) %>%
  select(stopwatch, `IPG Power Usage`, `Performance Counts`) %>%
  gather(metric, measure, -stopwatch)

ggplot(df, aes(x=stopwatch, y=measure)) +
  geom_point(aes(color=metric)) +
  facet_grid(rows = vars(metric), scales='free_y') +
  geom_vline(xintercept=60, linetype='dashed') +
  geom_vline(xintercept=120, linetype='dashed') +
  xlab('seconds') +
  labs(title='Lingscars') +
 guides(color=FALSE) + 
  theme_bw()
```

Navigation to Lingscars occurs between two dotted line, with the higher rate of power usage.

```{r, echo=FALSE}
calc_diff <- function(pwr_drain, stopwatch, region) {
  x <- pwr_drain[between(stopwatch, region[1], region[2])]
  delta <- (diff(range(x))[1])
  return(delta)
  
}

calc_region_diff <- function(prefs, exps){
  perf_merged <- exps[[prefs]]
  slopes <- list()
  for (exp in names(perf_merged)){
    df <- perf_merged[[exp]] %>%
      rename(pwr_drain = battery_drain) %>%
      group_by(run_id) %>%
      # filter(run_id == 1) %>%
      summarize(before = calc_diff(pwr_drain, stopwatch, region=c(10,50)),
                during = calc_diff(pwr_drain, stopwatch, region=c(70, 120)),
                after = calc_diff(pwr_drain, stopwatch, region=c(130, 160))) %>%
      mutate(run_id = as.character(run_id), exp=exp, prefs=prefs)
    slopes[[exp]] <- df
  }
  slopes_df <- bind_rows(slopes)
  return(slopes_df)
}

nav_diff <- lapply(names(exp_types), calc_region_diff, exps=exp_types) %>%
   bind_rows()
```

## Before
```{r, echo=FALSE}
ggplot(nav_diff[nav_diff$run_id<5,], aes(run_id, before, fill=prefs)) + 
  geom_violin(position = position_dodge(width=0.8)) + 
  geom_boxplot(width=0.1, position=position_dodge(width=0.8)) + 
  xlab('Run ID') + 
  ylab('Power Drain: Before')+
  theme_bw()
```

What is the the huge outlier:

```{r, warning=FALSE, message=FALSE}
kable(nav_diff[nav_diff$before >120, ], format='latex')
```

Popping out this record and replotting:

```{r, echo=FALSE}
ggplot(nav_diff[nav_diff$run_id<5 & nav_diff$before < 120,], aes(run_id, before, fill=prefs)) + 
  geom_violin(position = position_dodge(width=0.8)) + 
  geom_boxplot(width=0.1, position=position_dodge(width=0.8)) + 
  xlab('Run ID') + 
  ylab('Power Drain: Before')+
  theme_bw()
```

The #1 run for both prefs is higher than the remaining run, but is especially significant for block autoplay off. This is what is resulting in the large difference in observed total power conusmption.

**Observation**: What is interesting is that there is a difference between the prefs right after Firefox has been started, _before_ navigation to the experiment URL has occurred. This is consistent across all experiment runs!

**TODO**: Another experiment needs to be performed to determine the robustness of this result. (see above)

* Perform experiments with pref-flipping between each run, rather than running a full suite with pref frozen

## During
```{r, echo=FALSE}
ggplot(nav_diff[nav_diff$run_id<5 & nav_diff$before < 120,], aes(run_id, during, fill=prefs)) + 
  geom_violin(position = position_dodge(width=0.8)) + 
  geom_boxplot(width=0.1, position=position_dodge(width=0.8)) + 
  xlab('Run ID') + 
  ylab('Power Drain: At URL')+
  theme_bw()
```

As expected, increase power usage while at the URL. 


## After 
```{r, echo=FALSE}
ggplot(nav_diff[nav_diff$run_id<5 & nav_diff$before < 120,], aes(run_id, after, fill=prefs)) + 
  geom_violin(position = position_dodge(width=0.8)) + 
  geom_boxplot(width=0.1, position=position_dodge(width=0.8)) + 
  xlab('Run ID') + 
  ylab('Power Drain: After')+
  theme_bw()
```

The first run for block autoplay off is again high. There is a lot of variation between the prefs, with the observed increase in block autoplay off in runs 1,2 and 4, but absent in 3. 

## By Pref

```{r, echo=FALSE, warning=FALSE}
nav_diff %>%
  filter(before < 120) %>%
  gather(metric, measure, -run_id, -prefs, -exp) -> nav_df

ggplot(nav_df[nav_df$run_id<5 &
                   nav_df$prefs=='blockautoplay_off_tpstrict_off',], aes(metric, measure, fill=run_id)) + 
  geom_boxplot() + 
  xlab('Run ID') + 
  ylab('IPG CPU Power Drain') + 
  labs(title = 'Block Autoplay Off') +
  coord_cartesian(ylim = c(25, 150))+
  theme_bw()
```



```{r, echo=FALSE}
ggplot(nav_df[nav_df$run_id<5 &
                   nav_df$prefs=='blockautoplay_on_tpstrict_off',], aes(metric, measure, fill=run_id)) + 
  geom_boxplot() + 
  xlab('Run ID') + 
  ylab('IPG CPU Power Drain') + 
  labs(title = 'Block Autoplay On') +
  coord_cartesian(ylim = c(25, 150))+
  theme_bw()
```

The first run for both prefs does have higher distribution values for the initial start-up to URL navigation. Again, this needs to be investigated with further experiments. 
